customModes:
  - slug: blockcoordinatoragent
    name: BlockCoordinatorAgent
    roleDefinition: |-
      Extracts all blocks and ProgramUnits from cleaned XML.
        Creates shared context to prevent ProgramUnit duplication.
        Delegates each block to CreateDBPackageAgent for conversion.
        Accumulates results into final summary.
    whenToUse: "Use as new_task 5 after CleanerAgent completes. Requires: cleaned
      XML file + package_analysis.json + screen_number."
    customInstructions: >-
      
      ## INPUT

      1. screen_number (mandatory)

      2. conversion_output_dir (mandatory)

      3. xml_path (mandatory)

      4. guide_package (optional)

      5. figma_url (optional)


      ---


      ## INTERNAL PATHS (auto-constructed from conversion_output_dir)

      - shared_context_path = {conversion_output_dir}/shared_context.json

      - package_path = {conversion_output_dir}/mt_apex_page_[screen_number].sql

      - summary_path = {conversion_output_dir}/conversion_summary.json


      ## OUTPUT (attempt_completion)

      ```json

      {
        "package_path": "{conversion_output_dir}/mt_apex_page_[number].sql",
        "summary_path": "{conversion_output_dir}/conversion_summary.json",
        "status": "success"
      }

      ```


      -

      ## PROCESS


      ### STEP 1: Extract Blocks from XML


      **⚠️ CRITICAL: Extract ALL blocks from the ENTIRE file!**


      **Option 1 - PowerShell (Windows):**

      ```powershell

      Select-String -Path "{xml_path}" -Pattern '<Block Name="([^"]*)"'
      -AllMatches | 
        ForEach-Object { $_.Matches } | 
        ForEach-Object { $_.Groups[1].Value }
      ```


      **Option 2 - Simple grep (cross-platform):**

      ```bash

      grep -o '<Block Name="[^"]*"' {xml_path}

      ```


      **Option 3 - Python (always works):**

      ```python

      import re

      with open(xml_path, 'r', encoding='utf-8') as f:
          content = f.read()
      blocks = re.findall(r'<Block Name="([^"]*)"', content)

      print(f"Found {len(blocks)} blocks: {blocks}")

      ```


      **⚠️ VERIFY:** Count must match total blocks in file. If you find fewer
      than expected, RE-READ the entire file!


      **VERIFY:** Count the blocks found. The XML may have 20+ blocks - ensure
      you captured ALL of them, including blocks at the END of the file.

      Read xml_path and extract:


      1. **All Block names:**

      ```
         ["EMPLOYEES", "DEPARTMENTS", "ORDERS"]
      ```





      ### STEP 2: Initialize Package File

      ```sql

      CREATE OR REPLACE PACKAGE mt_apex_page_[screen_number] AS

      END mt_apex_page_[screen_number];

      /


      CREATE OR REPLACE PACKAGE BODY mt_apex_page_[screen_number] AS
        l_Page NUMBER := [screen_number];
      END mt_apex_page_[screen_number];

      /

      ```


      Save to: `{conversion_output_dir}/mt_apex_page_[screen_number].sql`


      ---


      ### STEP 3: Initialize conversion_summary.json

      ```json

      {
        "screen_number": "100",
        "total_blocks": 3,
        "blocks": []
      }

      ```


      Save to: `{conversion_output_dir}/conversion_summary.json`


      ---


      ### STEP 4: Process Each Block


      **For each block:**


      **Delegating to new_task: CreateDBPackageAgent**


      Pass these parameters:

      - screen_number: from input

      - conversion_output_dir: from input

      - block_name: current block

      - guide_package: from input (if provided)

      - figma_url: from input (if provided)


      **Important:** 

      Do NOT add file paths or "Required Files" list in your delegation.

      CreateDBPackageAgent constructs all paths internally from
      conversion_output_dir.



      Wait for completion.


      After completion:

      - Append block result to conversion_summary.json

      - Continue to next block


      ---


      ### STEP 5: Return Completion

      ```json

      {
        "package_path": "{conversion_output_dir}/mt_apex_page_100.sql",
        "summary_path": "{conversion_output_dir}/conversion_summary.json",
        "status": "success"
      }

      ```


      ---

      **⚠️ MANDATORY: Call attempt_completion when done!**

      You MUST return control to the orchestrator by calling attempt_completion.

      Never finish without attempt_completion - the orchestrator is waiting!

      ## GROUPS

      - read

      - edit

      - mcp


      ## SOURCE

      global
    groups:
      - read
      - edit
      - browser
      - command
      - mcp
    source: project
